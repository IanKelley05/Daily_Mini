<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Daily Mini</title>
    <style>
        :root {
            /* 1. INCREASED SIZE HERE */
            --cell-size: 75px; 
            --highlight-blue: #A7D8FF;
            --selected-yellow: #FFDA00;
            --black-cell: #000000;
            --border-color: #333;
            --wrong-color: #e00;
            --revealed-color: #0a7a0a; /* Green for revealed letters */
        }

        body {
            font-family: 'nyt-franklin', 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f8f8f8;
            height: 100vh;
        }

        header {
            width: 100%;
            padding: 15px 0;
            text-align: center;
            border-bottom: 1px solid #ccc;
            background: white;
            position: relative;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 800;
            letter-spacing: -0.5px;
        }

        #timer {
            margin-top: 5px;
            font-weight: bold;
            color: #555;
            font-size: 0.9rem;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(5, var(--cell-size));
            grid-template-rows: repeat(5, var(--cell-size));
            gap: 0;
            border: 2px solid var(--black-cell);
            margin-bottom: 20px;
            background: var(--black-cell);
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: white;
            border: 1px solid #888;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            user-select: none;
        }

        .cell input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            text-transform: uppercase;
            background: transparent;
            outline: none;
            padding: 0;
            margin: 0;
            color: black;
            font-family: inherit;
            cursor: pointer;
            caret-color: transparent; 
        }

        .cell input.wrong {
            color: var(--wrong-color);
            text-decoration: line-through;
        }

        /* New style for revealed letters */
        .cell input.revealed {
            color: var(--revealed-color);
        }

        .cell-number {
            position: absolute;
            top: 4px;
            left: 4px;
            font-size: 14px;
            font-weight: normal;
            pointer-events: none;
        }

        .cell.black {
            background-color: var(--black-cell);
            border-color: var(--black-cell);
            pointer-events: none;
        }

        .cell.highlight-word {
            background-color: var(--highlight-blue);
        }

        .cell.selected {
            background-color: var(--selected-yellow) !important;
        }

        #toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            flex-wrap: wrap; /* Allows buttons to wrap on small screens */
            justify-content: center;
        }

        .action-btn {
            background: white;
            border: 1px solid #ccc;
            padding: 8px 12px;
            font-size: 0.85rem;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            color: #333;
            transition: background 0.2s;
            margin-bottom: 5px;
        }

        .action-btn:hover {
            background: #eee;
        }

        #clues {
            width: 100%;
            display: flex;
            justify-content: space-between;
            max-width: 500px;
        }

        .clue-column {
            width: 48%;
        }

        .clue-header {
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.8rem;
            border-bottom: 1px solid #ccc;
            margin-bottom: 10px;
            padding-bottom: 5px;
        }

        .clue-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 1rem;
        }

        .clue-item {
            margin-bottom: 10px;
            cursor: pointer;
            line-height: 1.4;
        }

        .clue-item.active-clue {
            background-color: var(--highlight-blue);
            font-weight: bold;
        }

        .clue-number {
            font-weight: bold;
            margin-right: 5px;
        }

        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #modal {
            background: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            max-width: 80%;
        }

        button.btn-primary {
            background: black;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 20px;
            margin-top: 15px;
        }

        @media (max-width: 600px) {
            :root {
                --cell-size: 17vw; 
            }
            .cell, .cell input {
                font-size: 26px;
            }
            #clues {
                flex-direction: column;
            }
            .clue-column {
                width: 100%;
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>

<header>
    <h1>The Mini For My Mini</h1>
    <div id="timer">0:00</div>
</header>

<div id="game-container">
    <div id="grid"></div>

    <div id="toolbar">
        <button class="action-btn" onclick="checkSquare()">Check Square</button>
        <button class="action-btn" onclick="checkWord()">Check Word</button>
        <button class="action-btn" onclick="checkGrid()">Check Puzzle</button>
        <button class="action-btn" onclick="revealSquare()">Reveal Square</button>
        <button class="action-btn" onclick="revealWord()">Reveal Word</button>
    </div>

    <div id="clues">
        <div class="clue-column">
            <div class="clue-header">Across</div>
            <ul id="across-clues" class="clue-list"></ul>
        </div>
        <div class="clue-column">
            <div class="clue-header">Down</div>
            <ul id="down-clues" class="clue-list"></ul>
        </div>
    </div>
</div>

<div id="modal-overlay">
    <div id="modal">
        <h2>Puzzle Solved!</h2>
        <p>You finished in <span id="final-time"></span>!</p>
        <button class="btn-primary" onclick="closeModal()">Play Again</button>
    </div>
</div>

<script>
    // --- PUZZLE DATA ---
    const PUZZLE_DATA = {
        grid: [
            ['K', 'A', 'T', 'I', 'E'], // Use a . for a black square
            ['P', 'U', 'N', 'T', 'S'],
            ['.', 'R', 'U', 'S', 'S'],
            ['.', 'A', 'T', 'M', 'E'],
            ['.', '.', 'S', 'E', 'X']
        ],
        clues: {
            across: [
                { num: 1, text: "Worst drunk person in VPR" },
                { num: 6, text: "The funny sports reel we saw where the guy _____ the ball but misses" },
                { num: 7, text: "Short for Russell" },
                { num: 8, text: "Look __ __ song by XXXtentacion" },
                { num: 9, text: "Literally the best thing ever" }
            ],
            down: [
                { num: 1, text: "Goated BIO teacher" },
                { num: 2, text: "Something I have infinite of" },
                { num: 3, text: "Used to create a strong, reusable threaded connection in materials like wood" },
                { num: 4, text: "___ a __ super mario" },
                { num: 5, text: "Where everyone from love island UK is from" }
            ]
        }
    };

    const gridEl = document.getElementById('grid');
    const acrossList = document.getElementById('across-clues');
    const downList = document.getElementById('down-clues');
    const timerEl = document.getElementById('timer');
    const modal = document.getElementById('modal-overlay');
    const finalTimeSpan = document.getElementById('final-time');

    // State
    let currentDirection = 'across'; 
    let selectedCell = { r: 0, c: 0 };
    let timerInterval;
    let seconds = 0;
    let isSolved = false;

    function init() {
        buildGrid();
        renderClues();
        startTimer();
        selectCell(0, 0);
    }

    function buildGrid() {
        gridEl.innerHTML = '';
        for (let r = 0; r < 5; r++) {
            for (let c = 0; c < 5; c++) {
                const cellDiv = document.createElement('div');
                cellDiv.className = 'cell';
                cellDiv.dataset.r = r;
                cellDiv.dataset.c = c;

                const letter = PUZZLE_DATA.grid[r][c];
                
                if (letter === '.') {
                    cellDiv.classList.add('black');
                } else {
                    const num = getNumberForCell(r, c);
                    if (num) {
                        const numSpan = document.createElement('span');
                        numSpan.className = 'cell-number';
                        numSpan.innerText = num;
                        cellDiv.appendChild(numSpan);
                    }
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.maxLength = 1;
                    
                    // Events
                    input.addEventListener('mousedown', (e) => handleMousedown(r, c, e));
                    input.addEventListener('focus', () => handleFocus(r, c));
                    input.addEventListener('keydown', (e) => handleKey(r, c, e));
                    input.addEventListener('input', (e) => handleInput(r, c, e));
                    cellDiv.appendChild(input);
                }
                gridEl.appendChild(cellDiv);
            }
        }
    }

    function getNumberForCell(r, c) {
        let count = 1;
        for(let i=0; i<5; i++) {
            for(let j=0; j<5; j++) {
                if(PUZZLE_DATA.grid[i][j] === '.') continue;
                let startAcross = (j===0 || PUZZLE_DATA.grid[i][j-1] === '.');
                let startDown = (i===0 || PUZZLE_DATA.grid[i-1][j] === '.');
                if(startAcross || startDown) {
                    if(i === r && j === c) return count;
                    count++;
                }
            }
        }
        return null;
    }

    function renderClues() {
        PUZZLE_DATA.clues.across.forEach(clue => {
            const li = document.createElement('li');
            li.className = 'clue-item';
            li.id = `across-${clue.num}`;
            li.innerHTML = `<span class="clue-number">${clue.num}</span> ${clue.text}`;
            li.addEventListener('click', () => {
                currentDirection = 'across';
                focusClueCell(clue.num, 'across');
            });
            acrossList.appendChild(li);
        });

        PUZZLE_DATA.clues.down.forEach(clue => {
            const li = document.createElement('li');
            li.className = 'clue-item';
            li.id = `down-${clue.num}`;
            li.innerHTML = `<span class="clue-number">${clue.num}</span> ${clue.text}`;
            li.addEventListener('click', () => {
                currentDirection = 'down';
                focusClueCell(clue.num, 'down');
            });
            downList.appendChild(li);
        });
    }

    function startTimer() {
        timerInterval = setInterval(() => {
            seconds++;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            timerEl.innerText = `${mins}:${secs.toString().padStart(2, '0')}`;
        }, 1000);
    }

    function stopTimer() {
        clearInterval(timerInterval);
    }

    function handleFocus(r, c) {
        selectedCell = { r, c };
        highlightGrid();
    }

    function handleMousedown(r, c, e) {
        if (selectedCell.r === r && selectedCell.c === c) {
            currentDirection = currentDirection === 'across' ? 'down' : 'across';
            highlightGrid();
        } else {
            selectedCell = { r, c };
            highlightGrid();
        }
    }

    function handleInput(r, c, e) {
        const val = e.target.value.toUpperCase();
        const input = getInput(r, c);
        input.value = val;
        
        input.classList.remove('wrong');
        // Remove revealed status if user types manually
        input.classList.remove('revealed');

        if (val) {
            smartAdvanceCursor(r, c);
        }
        checkWin();
    }

    function handleKey(r, c, e) {
        if (e.key === 'Backspace') {
            const input = getInput(r, c);
            input.classList.remove('wrong');
            input.classList.remove('revealed');
            
            if (input.value === '') {
                moveBack(r, c);
                e.preventDefault();
            } else {
                input.value = '';
            }
        } else if (e.key.startsWith('Arrow')) {
            e.preventDefault();
            
            // 2. ARROW KEY LOGIC
            
            // If trying to move Vertically...
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                if (currentDirection === 'across') {
                    // Pivot to DOWN, but don't move yet
                    currentDirection = 'down';
                    highlightGrid();
                    return;
                }
            }

            // If trying to move Horizontally...
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                if (currentDirection === 'down') {
                    // Pivot to ACROSS, but don't move yet
                    currentDirection = 'across';
                    highlightGrid();
                    return;
                }
            }

            // If we are already in the correct direction, or just switched, allow movement
            if (e.key === 'ArrowRight') moveSelection(0, 1);
            if (e.key === 'ArrowLeft') moveSelection(0, -1);
            if (e.key === 'ArrowUp') moveSelection(-1, 0);
            if (e.key === 'ArrowDown') moveSelection(1, 0);
        }
    }

    function moveSelection(dr, dc) {
        let nr = selectedCell.r + dr;
        let nc = selectedCell.c + dc;
        if (nr >= 0 && nr < 5 && nc >= 0 && nc < 5) {
            if (PUZZLE_DATA.grid[nr][nc] !== '.') {
                selectCell(nr, nc);
            }
        }
    }

    function moveBack(r, c) {
        let nr = r;
        let nc = c;
        if (currentDirection === 'across') nc--;
        else nr--;

        if (nr >= 0 && nr < 5 && nc >= 0 && nc < 5) {
             if (PUZZLE_DATA.grid[nr][nc] !== '.') {
                 const prev = getInput(nr, nc);
                 if(prev) {
                    prev.value = '';
                    prev.classList.remove('wrong');
                    prev.classList.remove('revealed');
                    selectCell(nr, nc);
                 }
             }
        }
    }

    function smartAdvanceCursor(r, c) {
        let currR = r;
        let currC = c;
        
        while(true) {
            if (currentDirection === 'across') currC++;
            else currR++;

            if (currR >= 5 || currC >= 5 || currR < 0 || currC < 0) break; 
            if (PUZZLE_DATA.grid[currR][currC] === '.') break;

            const input = getInput(currR, currC);
            if (input && input.value === '') {
                selectCell(currR, currC);
                return; 
            }
        }
    }

    function selectCell(r, c) {
        selectedCell = { r, c };
        const input = getInput(r, c);
        if(input) {
            input.focus();
            highlightGrid();
        }
    }

    function getInput(r, c) {
        const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
        return cell ? cell.querySelector('input') : null;
    }

    function highlightGrid() {
        document.querySelectorAll('.cell').forEach(c => {
            c.classList.remove('selected', 'highlight-word');
        });
        document.querySelectorAll('.clue-item').forEach(c => c.classList.remove('active-clue'));

        const cell = document.querySelector(`.cell[data-r="${selectedCell.r}"][data-c="${selectedCell.c}"]`);
        if (cell) cell.classList.add('selected');

        highlightWordAndClue(selectedCell.r, selectedCell.c);
    }

    function highlightWordAndClue(r, c) {
        let startR = r;
        let startC = c;

        if (currentDirection === 'across') {
            while (startC > 0 && PUZZLE_DATA.grid[startR][startC - 1] !== '.') {
                startC--;
            }
            let iterC = startC;
            while (iterC < 5 && PUZZLE_DATA.grid[startR][iterC] !== '.') {
                const hCell = document.querySelector(`.cell[data-r="${startR}"][data-c="${iterC}"]`);
                if(hCell) hCell.classList.add('highlight-word');
                iterC++;
            }
            const num = getNumberForCell(startR, startC);
            if(num) highlightClue(num, 'across');

        } else {
            while (startR > 0 && PUZZLE_DATA.grid[startR - 1][startC] !== '.') {
                startR--;
            }
            let iterR = startR;
            while (iterR < 5 && PUZZLE_DATA.grid[iterR][startC] !== '.') {
                const hCell = document.querySelector(`.cell[data-r="${iterR}"][data-c="${startC}"]`);
                if(hCell) hCell.classList.add('highlight-word');
                iterR++;
            }
            const num = getNumberForCell(startR, startC);
            if(num) highlightClue(num, 'down');
        }
    }

    function highlightClue(num, dir) {
        const el = document.getElementById(`${dir}-${num}`);
        if (el) {
            el.classList.add('active-clue');
            el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }

    function focusClueCell(num, dir) {
        for(let r=0; r<5; r++) {
            for(let c=0; c<5; c++) {
                if (getNumberForCell(r, c) === num) {
                    selectCell(r, c);
                    return;
                }
            }
        }
    }

    function validateCell(r, c) {
        const input = getInput(r, c);
        if (!input || input.value === '') return;
        
        const correctLetter = PUZZLE_DATA.grid[r][c];
        if (input.value.toUpperCase() !== correctLetter) {
            input.classList.add('wrong');
        } else {
            input.classList.remove('wrong'); 
        }
    }

    function checkSquare() {
        validateCell(selectedCell.r, selectedCell.c);
        const input = getInput(selectedCell.r, selectedCell.c);
        if(input) input.focus();
    }

    function checkWord() {
        let r = selectedCell.r;
        let c = selectedCell.c;
        
        if (currentDirection === 'across') {
            while (c > 0 && PUZZLE_DATA.grid[r][c - 1] !== '.') c--;
            while (c < 5 && PUZZLE_DATA.grid[r][c] !== '.') {
                validateCell(r, c);
                c++;
            }
        } else {
            while (r > 0 && PUZZLE_DATA.grid[r - 1][c] !== '.') r--;
            while (r < 5 && PUZZLE_DATA.grid[r][c] !== '.') {
                validateCell(r, c);
                r++;
            }
        }
        
        const input = getInput(selectedCell.r, selectedCell.c);
        if(input) input.focus();
    }

    function checkGrid() {
        for(let r=0; r<5; r++) {
            for(let c=0; c<5; c++) {
                if(PUZZLE_DATA.grid[r][c] !== '.') {
                    validateCell(r, c);
                }
            }
        }
        const input = getInput(selectedCell.r, selectedCell.c);
        if(input) input.focus();
    }

    // --- REVEAL FUNCTIONS ---

    function revealSquare() {
        const r = selectedCell.r;
        const c = selectedCell.c;
        const input = getInput(r, c);
        
        if(input) {
            input.value = PUZZLE_DATA.grid[r][c];
            input.classList.remove('wrong');
            input.classList.add('revealed');
        }
        
        // Return focus
        if(input) input.focus();
        checkWin();
    }

    function revealWord() {
        let r = selectedCell.r;
        let c = selectedCell.c;
        
        if (currentDirection === 'across') {
            // Find start
            while (c > 0 && PUZZLE_DATA.grid[r][c - 1] !== '.') c--;
            // Iterate forward
            while (c < 5 && PUZZLE_DATA.grid[r][c] !== '.') {
                const input = getInput(r, c);
                if(input) {
                    input.value = PUZZLE_DATA.grid[r][c];
                    input.classList.remove('wrong');
                    input.classList.add('revealed');
                }
                c++;
            }
        } else {
            // Find start
            while (r > 0 && PUZZLE_DATA.grid[r - 1][c] !== '.') r--;
            // Iterate down
            while (r < 5 && PUZZLE_DATA.grid[r][c] !== '.') {
                const input = getInput(r, c);
                if(input) {
                    input.value = PUZZLE_DATA.grid[r][c];
                    input.classList.remove('wrong');
                    input.classList.add('revealed');
                }
                r++;
            }
        }
        
        // Return focus
        const input = getInput(selectedCell.r, selectedCell.c);
        if(input) input.focus();
        checkWin();
    }

    function checkWin() {
        if (isSolved) return;
        
        let correct = true;
        let filled = true;

        for (let r = 0; r < 5; r++) {
            for (let c = 0; c < 5; c++) {
                if (PUZZLE_DATA.grid[r][c] === '.') continue;
                const input = getInput(r, c);
                if (!input.value) {
                    filled = false;
                    break;
                }
                if (input.value.toUpperCase() !== PUZZLE_DATA.grid[r][c]) {
                    correct = false;
                }
            }
        }

        if (filled && correct) {
            isSolved = true;
            stopTimer();
            finalTimeSpan.innerText = timerEl.innerText;
            setTimeout(() => {
                modal.style.display = 'flex';
            }, 500);
        }
    }

    function closeModal() {
        modal.style.display = 'none';
        location.reload();
    }

    init();
</script>

</body>
</html>